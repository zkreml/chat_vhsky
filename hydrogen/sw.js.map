{"version":3,"file":"sw.js","sources":["../src/platform/web/sw.js"],"sourcesContent":["/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nconst NOTIFICATION_BADGE_ICON = \"icon.png\";\n\n// These are replaced by rollup plugins\nconst UNHASHED_PRECACHED_ASSETS = DEFINE_UNHASHED_PRECACHED_ASSETS;\nconst HASHED_PRECACHED_ASSETS = DEFINE_HASHED_PRECACHED_ASSETS;\nconst HASHED_CACHED_ON_REQUEST_ASSETS = DEFINE_HASHED_CACHED_ON_REQUEST_ASSETS;\n\nconst unhashedCacheName = `hydrogen-assets-${DEFINE_GLOBAL_HASH}`;\nconst hashedCacheName = `hydrogen-assets`;\nconst mediaThumbnailCacheName = `hydrogen-media-thumbnails-v2`;\n\nself.addEventListener(\"install\", function (e) {\n    e.waitUntil(\n        (async () => {\n            const unhashedCache = await caches.open(unhashedCacheName);\n            await unhashedCache.addAll(UNHASHED_PRECACHED_ASSETS);\n            const hashedCache = await caches.open(hashedCacheName);\n            await Promise.all(\n                HASHED_PRECACHED_ASSETS.map(async (asset) => {\n                    if (!(await hashedCache.match(asset))) {\n                        await hashedCache.add(asset);\n                    }\n                })\n            );\n        })()\n    );\n});\n\nself.addEventListener(\"activate\", (event) => {\n    // on a first page load/sw install,\n    // start using the service worker on all pages straight away\n    self.clients.claim();\n    event.waitUntil(purgeOldCaches());\n});\n\nasync function purgeOldCaches() {\n    // remove any caches we don't know about\n    const keyList = await caches.keys();\n    for (const key of keyList) {\n        if (\n            key !== unhashedCacheName &&\n            key !== hashedCacheName &&\n            key !== mediaThumbnailCacheName\n        ) {\n            await caches.delete(key);\n        }\n    }\n    // remove the cache for any old hashed resource\n    const hashedCache = await caches.open(hashedCacheName);\n    const keys = await hashedCache.keys();\n    const hashedAssetURLs = HASHED_PRECACHED_ASSETS.concat(\n        HASHED_CACHED_ON_REQUEST_ASSETS\n    ).map((a) => new URL(a, self.registration.scope).href);\n\n    for (const request of keys) {\n        if (!hashedAssetURLs.some((url) => url === request.url)) {\n            hashedCache.delete(request);\n        }\n    }\n}\n\nself.addEventListener(\"fetch\", (event) => {\n    /*\n    service worker shouldn't handle xhr uploads because otherwise\n    the progress events won't fire.\n    This has to do with xhr not being supported in service workers.\n    */\n    if (event.request.method === \"GET\") {\n        event.respondWith(handleRequest(event));\n    }\n});\n\nfunction isCacheableThumbnail(url) {\n    if (\n        url.pathname.startsWith(\"/_matrix/media/r0/thumbnail/\") ||\n        url.pathname.startsWith(\"/_matrix/client/v1/media/thumbnail/\")\n    ) {\n        const width = parseInt(url.searchParams.get(\"width\"), 10);\n        const height = parseInt(url.searchParams.get(\"height\"), 10);\n        if (width <= 50 && height <= 50) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst baseURL = new URL(self.registration.scope);\nlet pendingFetchAbortController = new AbortController();\n\nasync function handleRequest({ request, clientId }) {\n    try {\n        // Special caching strategy for config.json and theme json files\n        if (\n            request.url.includes(\"config.json\") ||\n            /theme-.+\\.json/.test(request.url)\n        ) {\n            return handleStaleWhileRevalidateRequest(request);\n        }\n\n        // rewrite / to /index.html so it hits the cache\n        const url = new URL(request.url);\n        if (\n            url.origin === baseURL.origin &&\n            url.pathname === baseURL.pathname\n        ) {\n            request = new Request(new URL(\"index.html\", baseURL.href));\n        }\n\n        // Add access token for authenticated media endpoints\n        const pathNameStartsWithMediaPrefix =\n            url.pathname.indexOf(\"/_matrix/client/v1/media\") === 0;\n        if (pathNameStartsWithMediaPrefix) {\n            const client = await self.clients.get(clientId);\n            const { accessToken, homeserver } = await sendAndWaitForReply(\n                client,\n                \"getAuthInfo\",\n                {}\n            );\n            if (!accessToken) {\n                throw new Error(\n                    \"Token returned from getAuthInfo message in sw.js is null!\"\n                );\n            }\n            if (!homeserver) {\n                throw new Error(\n                    \"homeserver returned from getAuthInfo message in sw.js is null!\"\n                );\n            }\n            // Is this request actually going to the homeserver?\n            const isRequestForHomeserver =\n                new URL(homeserver).origin === url.origin;\n            if (isRequestForHomeserver) {\n                // Only add the access-token if we know that this request\n                // is going to the homeserver.\n                const headers = new Headers(request.headers);\n                headers.set(\"authorization\", `Bearer ${accessToken}`);\n                request = new Request(request, {\n                    mode: \"cors\",\n                    credentials: \"omit\",\n                    headers,\n                });\n            }\n        }\n\n        let response = await readCache(request);\n        if (!response) {\n            // use cors so the resource in the cache isn't opaque and uses up to 7mb\n            // https://developers.google.com/web/tools/chrome-devtools/progressive-web-apps?utm_source=devtools#opaque-responses\n            if (isCacheableThumbnail(url)) {\n                response = await fetch(request, {\n                    signal: pendingFetchAbortController.signal,\n                    mode: \"cors\",\n                    credentials: \"omit\",\n                });\n            } else {\n                response = await fetch(request, {\n                    signal: pendingFetchAbortController.signal,\n                });\n            }\n            await updateCache(request, response);\n        }\n        return response;\n    } catch (err) {\n        if (err.name !== \"TypeError\" && err.name !== \"AbortError\") {\n            console.error(\"error in service worker\", err);\n        }\n        throw err;\n    }\n}\n\n/**\n * Stale-while-revalidate caching for certain files\n * see https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\n */\nasync function handleStaleWhileRevalidateRequest(request) {\n    let response = await readCache(request);\n    const networkResponsePromise = fetchAndUpdateCache(request);\n    if (response) {\n        return response;\n    } else {\n        return await networkResponsePromise;\n    }\n}\n\nasync function fetchAndUpdateCache(request) {\n    const response = await fetch(request, {\n        signal: pendingFetchAbortController.signal,\n        headers: {\n            \"Cache-Control\": \"no-cache\",\n        },\n    });\n    updateCache(request, response.clone());\n    return response;\n}\n\nasync function updateCache(request, response) {\n    // don't write error responses to the cache\n    if (response.status >= 400) {\n        return;\n    }\n    const url = new URL(request.url);\n    const baseURL = self.registration.scope;\n    if (isCacheableThumbnail(url)) {\n        const cache = await caches.open(mediaThumbnailCacheName);\n        cache.put(request, response.clone());\n    } else if (request.url.startsWith(baseURL)) {\n        let assetName = request.url.substr(baseURL.length);\n        let cacheName;\n        if (HASHED_CACHED_ON_REQUEST_ASSETS.includes(assetName)) {\n            cacheName = hashedCacheName;\n        } else if (UNHASHED_PRECACHED_ASSETS.includes(assetName)) {\n            cacheName = unhashedCacheName;\n        }\n        if (cacheName) {\n            const cache = await caches.open(cacheName);\n            await cache.put(request, response.clone());\n        }\n    }\n}\n\nasync function readCache(request) {\n    const unhashedCache = await caches.open(unhashedCacheName);\n    let response = await unhashedCache.match(request);\n    if (response) {\n        return response;\n    }\n    const hashedCache = await caches.open(hashedCacheName);\n    response = await hashedCache.match(request);\n    if (response) {\n        return response;\n    }\n\n    const url = new URL(request.url);\n    if (isCacheableThumbnail(url)) {\n        const mediaThumbnailCache = await caches.open(mediaThumbnailCacheName);\n        response = await mediaThumbnailCache.match(request);\n        // added in 0.1.26, remove previously cached error responses, remove this in some time\n        if (response?.status >= 400) {\n            await mediaThumbnailCache.delete(request);\n            response = null;\n        }\n    }\n    return response;\n}\n\nself.addEventListener(\"message\", (event) => {\n    const reply = (payload) =>\n        event.source.postMessage({ replyTo: event.data.id, payload });\n    const { replyTo } = event.data;\n    if (replyTo) {\n        const resolve = pendingReplies.get(replyTo);\n        if (resolve) {\n            pendingReplies.delete(replyTo);\n            resolve(event.data.payload);\n        }\n    } else {\n        switch (event.data?.type) {\n            case \"version\":\n                reply({\n                    version: DEFINE_VERSION,\n                    buildHash: DEFINE_GLOBAL_HASH,\n                });\n                break;\n            case \"skipWaiting\":\n                self.skipWaiting();\n                break;\n            case \"haltRequests\":\n                event.waitUntil(haltRequests().finally(() => reply()));\n                break;\n            case \"closeSession\":\n                event.waitUntil(\n                    closeSession(\n                        event.data.payload.sessionId,\n                        event.source.id\n                    ).finally(() => reply())\n                );\n                break;\n        }\n    }\n});\n\nconst NOTIF_TAG_NEW_MESSAGE = \"new_message\";\n\nasync function openClientFromNotif(event) {\n    if (event.notification.tag !== NOTIF_TAG_NEW_MESSAGE) {\n        console.log(\"clicked notif with tag\", event.notification.tag);\n        return;\n    }\n    const { sessionId, roomId } = event.notification.data;\n    const sessionHash = `#/session/${sessionId}`;\n    const roomHash = `${sessionHash}/room/${roomId}`;\n    const clientWithSession = await findClient(async (client) => {\n        return await sendAndWaitForReply(client, \"hasSessionOpen\", {\n            sessionId,\n        });\n    });\n    if (clientWithSession) {\n        console.log(\n            \"notificationclick: client has session open, showing room there\"\n        );\n        // use a message rather than clientWithSession.navigate here as this refreshes the page on chrome\n        clientWithSession.postMessage({\n            type: \"openRoom\",\n            payload: { roomId },\n        });\n        if (\"focus\" in clientWithSession) {\n            try {\n                await clientWithSession.focus();\n            } catch (err) {\n                console.error(err);\n            } // I've had this throw on me on Android\n        }\n    } else if (self.clients.openWindow) {\n        console.log(\n            \"notificationclick: no client found with session open, opening new window\"\n        );\n        const roomURL = new URL(`./${roomHash}`, baseURL).href;\n        await self.clients.openWindow(roomURL);\n    }\n}\n\nself.addEventListener(\"notificationclick\", (event) => {\n    event.notification.close();\n    event.waitUntil(openClientFromNotif(event));\n});\n\nasync function handlePushNotification(n) {\n    console.log(\"got a push message\", n);\n    const sessionId = n.session_id;\n    let sender = n.sender_display_name || n.sender;\n    if (sender && n.event_id) {\n        const roomId = n.room_id;\n        const hasFocusedClientOnRoom = !!(await findClient(async (client) => {\n            if (client.visibilityState === \"visible\" && client.focused) {\n                return await sendAndWaitForReply(client, \"hasRoomOpen\", {\n                    sessionId,\n                    roomId,\n                });\n            }\n        }));\n        if (hasFocusedClientOnRoom) {\n            console.log(\"client is focused, room is open, don't show notif\");\n            return;\n        }\n        const newMessageNotifs = Array.from(\n            await self.registration.getNotifications({\n                tag: NOTIF_TAG_NEW_MESSAGE,\n            })\n        );\n        const notifsForRoom = newMessageNotifs.filter(\n            (n) => n.data.roomId === roomId\n        );\n        const hasMultiNotification = notifsForRoom.some((n) => n.data.multi);\n        const hasSingleNotifsForRoom = newMessageNotifs.some(\n            (n) => !n.data.multi\n        );\n        const roomName = n.room_name || n.room_alias;\n        let multi = false;\n        let label;\n        let body;\n        if (hasMultiNotification) {\n            console.log(\"already have a multi message, don't do anything\");\n            return;\n        } else if (hasSingleNotifsForRoom) {\n            console.log(\"showing multi message notification\");\n            multi = true;\n            label = roomName || sender;\n            body = \"New messages\";\n        } else {\n            console.log(\"showing new message notification\");\n            if (roomName && roomName !== sender) {\n                label = `${sender} in ${roomName}`;\n            } else {\n                label = sender;\n            }\n            body = n.content?.body || \"New message\";\n        }\n        await self.registration.showNotification(label, {\n            body,\n            data: { sessionId, roomId, multi },\n            tag: NOTIF_TAG_NEW_MESSAGE,\n            badge: NOTIFICATION_BADGE_ICON,\n        });\n    }\n    // we could consider hiding previous notifications here based on the unread count\n    // (although we can't really figure out which notifications to hide) and also hiding\n    // notifications makes it hard to ensure we always show a notification after a push message\n    // when no client is visible, see https://goo.gl/yqv4Q4\n}\n\nself.addEventListener(\"push\", (event) => {\n    event.waitUntil(handlePushNotification(event.data.json()));\n});\n\nasync function closeSession(sessionId, requestingClientId) {\n    const clients = await self.clients.matchAll();\n    await Promise.all(\n        clients.map(async (client) => {\n            if (client.id !== requestingClientId) {\n                await sendAndWaitForReply(client, \"closeSession\", {\n                    sessionId,\n                });\n            }\n        })\n    );\n}\n\nasync function haltRequests() {\n    // first ask all clients to block sending any more requests\n    const clients = await self.clients.matchAll({ type: \"window\" });\n    await Promise.all(\n        clients.map((client) => {\n            return sendAndWaitForReply(client, \"haltRequests\");\n        })\n    );\n    // and only then abort the current requests\n    pendingFetchAbortController.abort();\n}\n\nconst pendingReplies = new Map();\nlet messageIdCounter = 0;\nfunction sendAndWaitForReply(client, type, payload) {\n    messageIdCounter += 1;\n    const id = messageIdCounter;\n    const promise = new Promise((resolve) => {\n        pendingReplies.set(id, resolve);\n    });\n    client.postMessage({ type, id, payload });\n    return promise;\n}\n\nasync function findClient(predicate) {\n    const clientList = await self.clients.matchAll({ type: \"window\" });\n    for (const client of clientList) {\n        if (await predicate(client)) {\n            return client;\n        }\n    }\n}\n"],"names":[],"mappings":"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"}